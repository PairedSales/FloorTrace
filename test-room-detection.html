<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloorTrace - Automated Room Detection Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        h1 { font-size: 24px; margin-bottom: 10px; }
        .status {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #3b82f6;
        }
        .status.success { border-left-color: #10b981; }
        .status.error { border-left-color: #ef4444; }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #1e293b;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        canvas {
            display: block;
            max-width: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .info-item {
            background: #f8fafc;
            padding: 10px;
            border-radius: 4px;
        }
        .info-label {
            font-size: 12px;
            color: #64748b;
            margin-bottom: 4px;
        }
        .info-value {
            font-size: 16px;
            font-weight: 600;
            color: #1e293b;
        }
        .log {
            background: #1e293b;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
        }
        .log-entry.error { color: #ef4444; }
        .log-entry.success { color: #10b981; }
        .log-entry.info { color: #3b82f6; }
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        button:hover { background: #2563eb; }
        button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ§ª FloorTrace - Automated Room Detection Test</h1>
            <p>Automatically tests room detection with ExampleFloorplan.png</p>
        </div>

        <div class="status" id="status">
            <strong>Status:</strong> <span id="statusText">Initializing...</span>
        </div>

        <div style="margin-bottom: 20px;">
            <button onclick="runTest()">Run Test Again</button>
            <button onclick="toggleDebugLogs()">Toggle Debug Logs</button>
        </div>

        <div class="grid">
            <div class="panel">
                <h2>Original Image</h2>
                <canvas id="originalCanvas"></canvas>
            </div>

            <div class="panel">
                <h2>Detected Room Overlay</h2>
                <canvas id="roomCanvas"></canvas>
            </div>

            <div class="panel">
                <h2>Detected Walls (All)</h2>
                <canvas id="wallsCanvas"></canvas>
            </div>

            <div class="panel">
                <h2>Interior vs Exterior Walls</h2>
                <canvas id="wallTypesCanvas"></canvas>
            </div>
        </div>

        <div class="panel">
            <h2>Detection Results</h2>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Detected Dimensions</div>
                    <div class="info-value" id="dimensions">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Room Box</div>
                    <div class="info-value" id="roomBox">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Total Walls</div>
                    <div class="info-value" id="totalWalls">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Interior Walls</div>
                    <div class="info-value" id="interiorWalls">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Exterior Walls</div>
                    <div class="info-value" id="exteriorWalls">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Test Result</div>
                    <div class="info-value" id="testResult">-</div>
                </div>
            </div>
        </div>

        <div class="panel" id="debugPanel" style="display: none;">
            <h2>Debug Console</h2>
            <div class="log" id="logContainer"></div>
        </div>
    </div>

    <script type="module">
        import Tesseract from 'https://cdn.jsdelivr.net/npm/tesseract.js@6/dist/tesseract.esm.min.js';

        const logs = [];
        let showDebug = false;

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = { timestamp, message, type };
            logs.push(entry);
            
            if (showDebug) {
                const logContainer = document.getElementById('logContainer');
                const div = document.createElement('div');
                div.className = `log-entry ${type}`;
                div.textContent = `[${timestamp}] ${message}`;
                logContainer.appendChild(div);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        window.toggleDebugLogs = () => {
            showDebug = !showDebug;
            const panel = document.getElementById('debugPanel');
            panel.style.display = showDebug ? 'block' : 'none';
            
            if (showDebug) {
                const logContainer = document.getElementById('logContainer');
                logContainer.innerHTML = '';
                logs.forEach(entry => {
                    const div = document.createElement('div');
                    div.className = `log-entry ${entry.type}`;
                    div.textContent = `[${entry.timestamp}] ${entry.message}`;
                    logContainer.appendChild(div);
                });
            }
        };

        function updateStatus(text, isError = false) {
            const status = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            statusText.textContent = text;
            status.className = isError ? 'status error' : 'status success';
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function imageToCanvas(img) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            return canvas;
        }

        function drawImageOnCanvas(img, canvasId) {
            const canvas = document.getElementById(canvasId);
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
        }

        function drawRoomOverlay(img, roomBox, canvasId) {
            const canvas = document.getElementById(canvasId);
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0);
            
            if (roomBox) {
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.strokeRect(roomBox.x1, roomBox.y1, 
                              roomBox.x2 - roomBox.x1, 
                              roomBox.y2 - roomBox.y1);
                
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                ctx.fillRect(roomBox.x1, roomBox.y1, 
                            roomBox.x2 - roomBox.x1, 
                            roomBox.y2 - roomBox.y1);
            }
        }

        function drawWalls(img, walls, canvasId, color = '#3b82f6') {
            const canvas = document.getElementById(canvasId);
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = color;
            walls.forEach(wall => {
                const { x1, y1, x2, y2 } = wall.boundingBox;
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
            });
        }

        function drawWallTypes(img, exterior, interior, canvasId) {
            const canvas = document.getElementById(canvasId);
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw exterior walls in red
            ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
            exterior.forEach(wall => {
                const { x1, y1, x2, y2 } = wall.boundingBox;
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
            });
            
            // Draw interior walls in blue
            ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
            interior.forEach(wall => {
                const { x1, y1, x2, y2 } = wall.boundingBox;
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
            });
        }

        async function detectWalls(img) {
            const canvas = imageToCanvas(img);
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            log('Converting image to binary...', 'info');
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const binary = new Uint8Array(width * height);
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                binary[i / 4] = brightness < 128 ? 1 : 0;
            }
            
            log('Finding connected components...', 'info');
            const components = findConnectedComponents(binary, width, height);
            log(`Found ${components.length} connected components`, 'success');
            
            const walls = filterWalls(components, 50);
            log(`Identified ${walls.length} wall segments`, 'success');
            
            const { horizontal, vertical } = classifyWalls(walls);
            log(`Classified: ${horizontal.length} horizontal, ${vertical.length} vertical`, 'success');
            
            const { exterior, interior } = separateExteriorInterior(horizontal, vertical, width, height);
            log(`Separated: ${exterior.length} exterior, ${interior.length} interior`, 'success');
            
            return { 
                allWalls: walls, 
                horizontal, 
                vertical, 
                exterior, 
                interior,
                imageSize: { width, height }
            };
        }

        function findConnectedComponents(binary, width, height) {
            const visited = new Uint8Array(width * height);
            const components = [];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (binary[idx] === 1 && visited[idx] === 0) {
                        const component = floodFill(binary, visited, width, height, x, y);
                        if (component.pixels.length > 0) {
                            components.push(component);
                        }
                    }
                }
            }
            
            return components;
        }

        function floodFill(binary, visited, width, height, startX, startY) {
            const pixels = [];
            let minX = width, maxX = 0, minY = height, maxY = 0;
            const queue = [{ x: startX, y: startY }];
            visited[startY * width + startX] = 1;
            
            while (queue.length > 0) {
                const { x, y } = queue.shift();
                pixels.push({ x, y });
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                
                const neighbors = [
                    { x: x + 1, y }, { x: x - 1, y },
                    { x, y: y + 1 }, { x, y: y - 1 }
                ];
                
                for (const n of neighbors) {
                    if (n.x >= 0 && n.x < width && n.y >= 0 && n.y < height) {
                        const nIdx = n.y * width + n.x;
                        if (binary[nIdx] === 1 && visited[nIdx] === 0) {
                            visited[nIdx] = 1;
                            queue.push(n);
                        }
                    }
                }
            }
            
            return {
                pixels,
                boundingBox: { x1: minX, y1: minY, x2: maxX, y2: maxY }
            };
        }

        function filterWalls(components, minLength) {
            return components.filter(comp => {
                const { x1, y1, x2, y2 } = comp.boundingBox;
                const width = x2 - x1;
                const height = y2 - y1;
                return Math.max(width, height) >= minLength;
            }).map(comp => ({
                ...comp,
                isHorizontal: (comp.boundingBox.x2 - comp.boundingBox.x1) > 
                              (comp.boundingBox.y2 - comp.boundingBox.y1),
                centerX: (comp.boundingBox.x1 + comp.boundingBox.x2) / 2,
                centerY: (comp.boundingBox.y1 + comp.boundingBox.y2) / 2
            }));
        }

        function classifyWalls(walls) {
            const horizontal = walls.filter(w => w.isHorizontal);
            const vertical = walls.filter(w => !w.isHorizontal);
            horizontal.sort((a, b) => a.centerY - b.centerY);
            vertical.sort((a, b) => a.centerX - b.centerX);
            return { horizontal, vertical };
        }

        function separateExteriorInterior(horizontal, vertical, width, height) {
            const edgeThreshold = Math.min(width, height) * 0.15;
            const exterior = [];
            const interior = [];
            
            horizontal.forEach(wall => {
                const distFromEdge = Math.min(wall.centerY, height - wall.centerY);
                (distFromEdge < edgeThreshold ? exterior : interior).push(wall);
            });
            
            vertical.forEach(wall => {
                const distFromEdge = Math.min(wall.centerX, width - wall.centerX);
                (distFromEdge < edgeThreshold ? exterior : interior).push(wall);
            });
            
            return { exterior, interior };
        }

        function findRoomFromWalls(wallData, dimensionBBox) {
            const { horizontal, vertical } = wallData;
            const centerX = dimensionBBox.x + dimensionBBox.width / 2;
            const centerY = dimensionBBox.y + dimensionBBox.height / 2;
            
            log(`Finding room for OCR at (${Math.round(centerX)}, ${Math.round(centerY)})`, 'info');
            
            const wallsAbove = horizontal.filter(w => w.centerY < centerY);
            const wallsBelow = horizontal.filter(w => w.centerY > centerY);
            const wallsLeft = vertical.filter(w => w.centerX < centerX);
            const wallsRight = vertical.filter(w => w.centerX > centerX);
            
            if (!wallsAbove.length || !wallsBelow.length || !wallsLeft.length || !wallsRight.length) {
                log('Not enough walls on all sides', 'error');
                return null;
            }
            
            wallsAbove.sort((a, b) => (centerY - a.centerY) - (centerY - b.centerY));
            wallsBelow.sort((a, b) => (b.centerY - centerY) - (a.centerY - centerY));
            wallsLeft.sort((a, b) => (centerX - a.centerX) - (centerX - b.centerX));
            wallsRight.sort((a, b) => (b.centerX - centerX) - (a.centerX - centerX));
            
            let bestRoom = null;
            let bestArea = 0;
            const minRoomSize = 100;
            const maxWallsToTest = 3;
            
            for (let t = 0; t < Math.min(maxWallsToTest, wallsAbove.length); t++) {
                for (let b = 0; b < Math.min(maxWallsToTest, wallsBelow.length); b++) {
                    for (let l = 0; l < Math.min(maxWallsToTest, wallsLeft.length); l++) {
                        for (let r = 0; r < Math.min(maxWallsToTest, wallsRight.length); r++) {
                            const room = {
                                x1: wallsLeft[l].boundingBox.x2,
                                y1: wallsAbove[t].boundingBox.y2,
                                x2: wallsRight[r].boundingBox.x1,
                                y2: wallsBelow[b].boundingBox.y1
                            };
                            
                            const w = room.x2 - room.x1;
                            const h = room.y2 - room.y1;
                            
                            if (w < minRoomSize || h < minRoomSize) continue;
                            if (dimensionBBox.x < room.x1 || 
                                dimensionBBox.x + dimensionBBox.width > room.x2 ||
                                dimensionBBox.y < room.y1 || 
                                dimensionBBox.y + dimensionBBox.height > room.y2) continue;
                            
                            const area = w * h;
                            const aspectRatio = Math.max(w, h) / Math.min(w, h);
                            if (aspectRatio > 5) continue;
                            
                            if (area > bestArea) {
                                bestArea = area;
                                bestRoom = room;
                            }
                        }
                    }
                }
            }
            
            if (bestRoom) {
                log(`Found room: ${Math.round(bestRoom.x2 - bestRoom.x1)}x${Math.round(bestRoom.y2 - bestRoom.y1)}px (area: ${Math.round(bestArea)}pxÂ²)`, 'success');
            } else {
                log('Could not find valid room', 'error');
            }
            
            return bestRoom;
        }

        async function runTest() {
            try {
                updateStatus('Loading ExampleFloorplan.png...');
                log('Starting automated test', 'info');
                
                const img = await loadImage('./ExampleFloorplan.png');
                log(`Image loaded: ${img.width}x${img.height}px`, 'success');
                
                drawImageOnCanvas(img, 'originalCanvas');
                
                updateStatus('Running OCR...');
                log('Starting OCR...', 'info');
                
                const canvas = imageToCanvas(img);
                const worker = await Tesseract.createWorker('eng');
                await worker.setParameters({
                    tessedit_char_whitelist: "0123456789'\"ftx .-",
                    tessedit_pageseg_mode: Tesseract.PSM.AUTO
                });
                
                const result = await worker.recognize(canvas, {}, { blocks: true });
                await worker.terminate();
                
                log('OCR complete', 'success');
                
                // Find first dimension
                const text = result.data.text;
                const match = text.match(/(\d+)\s*'\s*-?\s*(\d+)\s*"\s*x\s*(\d+)\s*'\s*-?\s*(\d+)\s*"/i);
                
                if (!match) {
                    throw new Error('No dimensions found in OCR text');
                }
                
                const width = parseInt(match[1]) + parseInt(match[2]) / 12;
                const height = parseInt(match[3]) + parseInt(match[4]) / 12;
                log(`Detected dimensions: ${width.toFixed(1)} x ${height.toFixed(1)} ft`, 'success');
                
                document.getElementById('dimensions').textContent = 
                    `${match[1]}'${match[2]}" x ${match[3]}'${match[4]}"`;
                
                // Find dimension bounding box
                let dimensionBBox = null;
                const words = [];
                if (result.data.blocks) {
                    for (const block of result.data.blocks) {
                        if (block.paragraphs) {
                            for (const para of block.paragraphs) {
                                if (para.lines) {
                                    for (const line of para.lines) {
                                        if (line.words) words.push(...line.words);
                                    }
                                }
                            }
                        }
                    }
                }
                
                for (const word of words) {
                    if (word.text && match[0].includes(word.text.replace(/\s/g, ''))) {
                        if (!dimensionBBox) {
                            dimensionBBox = {
                                x: word.bbox.x0,
                                y: word.bbox.y0,
                                width: word.bbox.x1 - word.bbox.x0,
                                height: word.bbox.y1 - word.bbox.y0
                            };
                        } else {
                            const minX = Math.min(dimensionBBox.x, word.bbox.x0);
                            const minY = Math.min(dimensionBBox.y, word.bbox.y0);
                            const maxX = Math.max(dimensionBBox.x + dimensionBBox.width, word.bbox.x1);
                            const maxY = Math.max(dimensionBBox.y + dimensionBBox.height, word.bbox.y1);
                            dimensionBBox = {
                                x: minX, y: minY,
                                width: maxX - minX,
                                height: maxY - minY
                            };
                        }
                    }
                }
                
                if (!dimensionBBox) {
                    throw new Error('Could not locate dimension text in image');
                }
                
                updateStatus('Detecting walls...');
                const wallData = await detectWalls(img);
                
                document.getElementById('totalWalls').textContent = wallData.allWalls.length;
                document.getElementById('interiorWalls').textContent = wallData.interior.length;
                document.getElementById('exteriorWalls').textContent = wallData.exterior.length;
                
                drawWalls(img, wallData.allWalls, 'wallsCanvas', '#3b82f6');
                drawWallTypes(img, wallData.exterior, wallData.interior, 'wallTypesCanvas');
                
                updateStatus('Finding room boundaries...');
                const roomBox = findRoomFromWalls(wallData, dimensionBBox);
                
                if (roomBox) {
                    const roomWidth = roomBox.x2 - roomBox.x1;
                    const roomHeight = roomBox.y2 - roomBox.y1;
                    document.getElementById('roomBox').textContent = 
                        `${Math.round(roomWidth)}x${Math.round(roomHeight)}px`;
                    
                    drawRoomOverlay(img, roomBox, 'roomCanvas');
                    
                    // Validate result
                    const expectedMinWidth = 200;
                    const expectedMinHeight = 200;
                    const isValid = roomWidth >= expectedMinWidth && roomHeight >= expectedMinHeight;
                    
                    document.getElementById('testResult').textContent = isValid ? 'âœ“ PASS' : 'âœ— FAIL';
                    document.getElementById('testResult').style.color = isValid ? '#10b981' : '#ef4444';
                    
                    if (isValid) {
                        updateStatus('âœ“ Test completed successfully!');
                        log('Test PASSED', 'success');
                    } else {
                        updateStatus('âš  Test completed with warnings', true);
                        log('Test FAILED: Room too small', 'error');
                    }
                } else {
                    throw new Error('Could not find room boundaries');
                }
                
            } catch (error) {
                updateStatus(`âœ— Error: ${error.message}`, true);
                log(`ERROR: ${error.message}`, 'error');
                console.error(error);
            }
        }

        window.runTest = runTest;

        // Auto-run on load
        window.addEventListener('load', () => {
            setTimeout(runTest, 500);
        });
    </script>
</body>
</html>
