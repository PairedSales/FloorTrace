<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Finding Test - Wall Detection & OCR Visualization</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      min-height: 100vh;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    .header h1 { font-size: 32px; margin-bottom: 10px; }
    .header p { font-size: 16px; opacity: 0.9; }
    .controls {
      padding: 30px;
      background: #f8f9fa;
      border-bottom: 2px solid #e9ecef;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    .control-group label {
      font-weight: 600;
      color: #495057;
      min-width: 150px;
    }
    .control-group input {
      padding: 8px 12px;
      border: 2px solid #dee2e6;
      border-radius: 6px;
      font-size: 14px;
    }
    .hint { color: #6c757d; font-size: 12px; }
    .button-group { display: flex; gap: 10px; margin-top: 20px; }
    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
    }
    button:hover:not(:disabled) { transform: translateY(-2px); }
    button:disabled { background: #adb5bd; cursor: not-allowed; }
    .results { padding: 30px; }
    .status-banner {
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-weight: 500;
    }
    .status-banner.success { background: #d4edda; color: #155724; }
    .status-banner.error { background: #f8d7da; color: #721c24; }
    .status-banner.info { background: #d1ecf1; color: #0c5460; }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin: 25px 0;
    }
    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      border-radius: 10px;
      color: white;
    }
    .stat-label { font-size: 12px; text-transform: uppercase; opacity: 0.9; }
    .stat-value { font-size: 32px; font-weight: bold; margin-top: 5px; }
    .section-title {
      font-size: 24px;
      color: #495057;
      margin: 30px 0 20px 0;
      padding-bottom: 10px;
      border-bottom: 3px solid #667eea;
    }
    .viz-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 25px;
      margin: 25px 0;
    }
    .viz-card {
      border: 2px solid #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .viz-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px;
      font-weight: 600;
    }
    .viz-content { padding: 15px; background: white; text-align: center; }
    .viz-content img { max-width: 100%; height: auto; border-radius: 6px; }
    .loading { text-align: center; padding: 60px 20px; }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .info-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 15px 0;
      border-left: 4px solid #667eea;
    }
    .flow-diagram {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .flow-step {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
    }
    .flow-arrow {
      color: #667eea;
      font-size: 24px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîç Room Finding Test System</h1>
      <p>Complete visualization of wall detection and room finding algorithms</p>
    </div>

    <div class="controls">
      <h3 style="margin-bottom: 15px; color: #495057;">‚öôÔ∏è Detection Settings</h3>
      <div class="control-group">
        <label for="minWallLength">Min Wall Length:</label>
        <input type="number" id="minWallLength" value="50" min="10" max="500" step="10">
        <span class="hint">Minimum pixels for wall detection (lower = more sensitive)</span>
      </div>
      <div class="button-group">
        <button id="runTest">‚ñ∂Ô∏è Run Room Finding Test</button>
        <button id="exportReport">üíæ Export Report</button>
      </div>
    </div>

    <div id="results" class="results"></div>
  </div>

  <script type="module">
    import { detectWalls, findRoomFromWalls } from './src/utils/wallDetector.js';
    import { detectAllDimensions } from './src/utils/roomDetector.js';
    import { dataUrlToImage, imageToCanvas } from './src/utils/imageLoader.js';

    let currentResults = null;

    // Load ExampleFloorplan.png automatically
    async function loadDefaultImage() {
      const response = await fetch('./ExampleFloorplan.png');
      const blob = await response.blob();
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    }

    // Create visualization canvases
    function createWallVisualization(wallData, imageDataUrl) {
      return new Promise(async (resolve) => {
        const img = await dataUrlToImage(imageDataUrl);
        const visualizations = {};

        // All walls visualization
        visualizations.allWalls = createWallCanvas(img.width, img.height, wallData.allWalls, 'All Walls');
        
        // Horizontal/Vertical classification
        visualizations.classified = createClassifiedWallsCanvas(img.width, img.height, wallData.horizontal, wallData.vertical);
        
        // Exterior/Interior separation
        visualizations.separated = createSeparatedWallsCanvas(img.width, img.height, wallData.exterior, wallData.interior);
        
        // Binary image
        visualizations.binary = createBinaryVisualization(img);

        resolve(visualizations);
      });
    }

    function createWallCanvas(width, height, walls, title) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      for (const wall of walls) {
        const { x1, y1, x2, y2 } = wall.boundingBox;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }

      return canvas.toDataURL();
    }

    function createClassifiedWallsCanvas(width, height, horizontal, vertical) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);

      // Horizontal in red
      ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
      for (const wall of horizontal) {
        const { x1, y1, x2, y2 } = wall.boundingBox;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }

      // Vertical in blue
      ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
      for (const wall of vertical) {
        const { x1, y1, x2, y2 } = wall.boundingBox;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }

      return canvas.toDataURL();
    }

    function createSeparatedWallsCanvas(width, height, exterior, interior) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);

      // Exterior in green
      ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
      ctx.strokeStyle = 'rgba(0, 128, 0, 1)';
      ctx.lineWidth = 2;
      for (const wall of exterior) {
        const { x1, y1, x2, y2 } = wall.boundingBox;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      }

      // Interior in purple
      ctx.fillStyle = 'rgba(128, 0, 128, 0.5)';
      ctx.strokeStyle = 'rgba(64, 0, 64, 1)';
      for (const wall of interior) {
        const { x1, y1, x2, y2 } = wall.boundingBox;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      }

      return canvas.toDataURL();
    }

    function createBinaryVisualization(img) {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      const threshold = 128;
      for (let i = 0; i < data.length; i += 4) {
        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
        const value = brightness < threshold ? 0 : 255;
        data[i] = data[i + 1] = data[i + 2] = value;
      }
      
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL();
    }

    async function createRoomFindingVisualization(imageDataUrl, wallData, dimensions) {
      const img = await dataUrlToImage(imageDataUrl);
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');

      // Draw original image
      ctx.drawImage(img, 0, 0);

      // Draw all walls lightly
      ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
      for (const wall of wallData.allWalls) {
        const { x1, y1, x2, y2 } = wall.boundingBox;
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }

      // Highlight dimension bboxes and rooms
      for (const dim of dimensions) {
        // Draw dimension bbox in yellow
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(dim.bbox.x, dim.bbox.y, dim.bbox.width, dim.bbox.height);
        ctx.setLineDash([]);

        // Try to find room
        const roomBox = findRoomFromWalls(wallData, dim.bbox);
        if (roomBox) {
          // Draw room box in bright green
          ctx.strokeStyle = 'lime';
          ctx.lineWidth = 3;
          ctx.strokeRect(roomBox.x1, roomBox.y1, roomBox.x2 - roomBox.x1, roomBox.y2 - roomBox.y1);

          // Add label
          ctx.font = 'bold 14px Arial';
          ctx.fillStyle = 'lime';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 3;
          ctx.strokeText(`${dim.width} √ó ${dim.height} ft`, roomBox.x1 + 5, roomBox.y1 + 20);
          ctx.fillText(`${dim.width} √ó ${dim.height} ft`, roomBox.x1 + 5, roomBox.y1 + 20);
        }
      }

      return canvas.toDataURL();
    }

    // Display results
    function displayResults(results) {
      const resultsDiv = document.getElementById('results');
      let html = '';

      html += `<div class="status-banner success">‚úì Room finding test completed successfully</div>`;

      // Algorithm flow
      html += '<h2 class="section-title">Algorithm Flow</h2>';
      html += '<div class="flow-diagram">';
      html += '<div class="flow-step">1. Load Image</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">2. Binary Conversion</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">3. Find Components</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">4. Filter Walls</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">5. Classify H/V</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">6. Separate Ext/Int</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">7. OCR Dimensions</div>';
      html += '<div class="flow-arrow">‚Üí</div>';
      html += '<div class="flow-step">8. Find Rooms</div>';
      html += '</div>';

      // Statistics
      html += '<h2 class="section-title">Detection Statistics</h2>';
      html += '<div class="stats-grid">';
      html += `<div class="stat-card"><div class="stat-label">Total Walls</div><div class="stat-value">${results.stats.totalWalls}</div></div>`;
      html += `<div class="stat-card"><div class="stat-label">Horizontal</div><div class="stat-value">${results.stats.horizontal}</div></div>`;
      html += `<div class="stat-card"><div class="stat-label">Vertical</div><div class="stat-value">${results.stats.vertical}</div></div>`;
      html += `<div class="stat-card"><div class="stat-label">Exterior</div><div class="stat-value">${results.stats.exterior}</div></div>`;
      html += `<div class="stat-card"><div class="stat-label">Interior</div><div class="stat-value">${results.stats.interior}</div></div>`;
      html += `<div class="stat-card"><div class="stat-label">Dimensions Found</div><div class="stat-value">${results.stats.dimensions}</div></div>`;
      html += '</div>';

      // Wall Detection Visualizations
      html += '<h2 class="section-title">Step-by-Step Wall Detection</h2>';
      html += '<div class="viz-grid">';
      
      html += `<div class="viz-card">
        <div class="viz-header">1Ô∏è‚É£ Binary Conversion (Threshold: 128)</div>
        <div class="viz-content">
          <img src="${results.viz.binary}" alt="Binary">
          <p style="margin-top: 10px; color: #6c757d; font-size: 12px;">Dark pixels become walls, light pixels become background</p>
        </div>
      </div>`;

      html += `<div class="viz-card">
        <div class="viz-header">2Ô∏è‚É£ All Detected Walls (${results.stats.totalWalls} walls)</div>
        <div class="viz-content">
          <img src="${results.viz.allWalls}" alt="All Walls">
          <p style="margin-top: 10px; color: #6c757d; font-size: 12px;">Connected components filtered by min length</p>
        </div>
      </div>`;

      html += `<div class="viz-card">
        <div class="viz-header">3Ô∏è‚É£ Horizontal/Vertical Classification</div>
        <div class="viz-content">
          <img src="${results.viz.classified}" alt="Classified">
          <p style="margin-top: 10px; color: #6c757d; font-size: 12px;">Red = Horizontal (${results.stats.horizontal}), Blue = Vertical (${results.stats.vertical})</p>
        </div>
      </div>`;

      html += `<div class="viz-card">
        <div class="viz-header">4Ô∏è‚É£ Exterior/Interior Separation</div>
        <div class="viz-content">
          <img src="${results.viz.separated}" alt="Separated">
          <p style="margin-top: 10px; color: #6c757d; font-size: 12px;">Green = Exterior (${results.stats.exterior}), Purple = Interior (${results.stats.interior})</p>
        </div>
      </div>`;

      html += '</div>';

      // Room Finding Results
      html += '<h2 class="section-title">Room Finding Results</h2>';
      html += '<div class="info-card">';
      html += '<strong>Algorithm:</strong> For each OCR dimension, find the largest rectangular room that:<br>';
      html += '1. Contains the dimension text<br>';
      html += '2. Uses interior wall edges (inner face of walls)<br>';
      html += '3. Has reasonable aspect ratio (not too elongated)<br>';
      html += '4. Maximizes room area (avoids selecting closets)';
      html += '</div>';

      if (results.dimensions.length > 0) {
        html += '<div class="viz-card" style="max-width: 100%;">';
        html += '<div class="viz-header">Complete Room Finding Visualization</div>';
        html += '<div class="viz-content">';
        html += `<img src="${results.viz.roomFinding}" alt="Room Finding">`;
        html += '<p style="margin-top: 10px; color: #6c757d; font-size: 12px;">Yellow dashed = OCR dimension boxes, Lime = Detected room boundaries</p>';
        html += '</div>';
        html += '</div>';

        html += '<h3 style="margin-top: 20px; color: #495057;">Detected Dimensions</h3>';
        html += '<div class="stats-grid">';
        for (const dim of results.dimensions) {
          html += `<div class="info-card">
            <strong>${dim.width} √ó ${dim.height} ft</strong><br>
            <small>Position: (${Math.round(dim.bbox.x)}, ${Math.round(dim.bbox.y)})<br>
            Size: ${Math.round(dim.bbox.width)}√ó${Math.round(dim.bbox.height)}px</small>
          </div>`;
        }
        html += '</div>';
      } else {
        html += '<div class="status-banner error">‚ö†Ô∏è No dimensions detected by OCR</div>';
      }

      resultsDiv.innerHTML = html;
    }

    // Run test
    document.getElementById('runTest').addEventListener('click', async () => {
      const button = document.getElementById('runTest');
      const resultsDiv = document.getElementById('results');

      try {
        button.disabled = true;
        resultsDiv.innerHTML = `
          <div class="loading">
            <div class="spinner"></div>
            <div class="loading-text">Running room finding test...</div>
            <p style="margin-top: 10px; color: #6c757d;">Detecting walls, running OCR, and finding rooms</p>
          </div>
        `;

        const imageDataUrl = await loadDefaultImage();
        const minWallLength = parseInt(document.getElementById('minWallLength').value);

        // Step 1: Detect walls
        console.log('Step 1: Detecting walls...');
        const wallData = await detectWalls(imageDataUrl, {
          minWallLength,
          debugMode: false
        });

        // Step 2: Run OCR to find dimensions
        console.log('Step 2: Running OCR...');
        const { dimensions } = await detectAllDimensions(imageDataUrl);

        // Step 3: Create visualizations
        console.log('Step 3: Creating visualizations...');
        const viz = await createWallVisualization(wallData, imageDataUrl);
        viz.roomFinding = await createRoomFindingVisualization(imageDataUrl, wallData, dimensions);

        currentResults = {
          wallData,
          dimensions,
          viz,
          stats: {
            totalWalls: wallData.allWalls.length,
            horizontal: wallData.horizontal.length,
            vertical: wallData.vertical.length,
            exterior: wallData.exterior.length,
            interior: wallData.interior.length,
            dimensions: dimensions.length
          }
        };

        displayResults(currentResults);
      } catch (error) {
        resultsDiv.innerHTML = `
          <div class="status-banner error">
            ‚ö†Ô∏è Error: ${error.message}
            <pre style="margin-top: 10px; font-size: 12px;">${error.stack}</pre>
          </div>
        `;
        console.error('Test error:', error);
      } finally {
        button.disabled = false;
      }
    });

    // Export report
    document.getElementById('exportReport').addEventListener('click', () => {
      if (currentResults) {
        const report = {
          timestamp: new Date().toISOString(),
          statistics: currentResults.stats,
          dimensions: currentResults.dimensions.map(d => ({
            width: d.width,
            height: d.height,
            position: { x: d.bbox.x, y: d.bbox.y }
          }))
        };
        const json = JSON.stringify(report, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'room-finding-test-report.json';
        a.click();
        URL.revokeObjectURL(url);
      } else {
        alert('No results to export. Run a test first.');
      }
    });

    // Auto-run on load
    window.addEventListener('load', () => {
      console.log('Auto-running room finding test with ExampleFloorplan.png');
      setTimeout(() => {
        document.getElementById('runTest').click();
      }, 500);
    });
  </script>
</body>
</html>
